# Transcribed 2023-11-10 with medium model size

1
0:00:00,000 --> 0:00:12,200
 For our next speaker, we have Nikolaj who will be talking about some sexy SSH hacks.

2
0:00:12,200 --> 0:00:16,800
 Make sure to give him a round of applause.

3
0:00:16,800 --> 0:00:21,160
 All right.

4
0:00:21,160 --> 0:00:26,720
 So hopefully you are ready for 45 minutes of random SSH talk.

5
0:00:26,720 --> 0:00:31,320
 So question, how many people have used SSH before?

6
0:00:31,320 --> 0:00:32,320
 A lot of people.

7
0:00:32,320 --> 0:00:33,320
 Great.

8
0:00:33,320 --> 0:00:35,240
 If you haven't used SSH before, this is going to be very boring.

9
0:00:35,240 --> 0:00:38,200
 How many have used it within the last month?

10
0:00:38,200 --> 0:00:39,200
 And a week?

11
0:00:39,200 --> 0:00:40,200
 Today?

12
0:00:40,200 --> 0:00:41,200
 Okay.

13
0:00:41,200 --> 0:00:43,000
 A lot of people.

14
0:00:43,000 --> 0:00:44,000
 Great.

15
0:00:44,000 --> 0:00:49,880
 So I use SSH maybe not on a daily basis, but at least on a weekly basis.

16
0:00:49,880 --> 0:00:54,920
 And I probably use it the same way as you use it, you know, SSH into a random server

17
0:00:54,920 --> 0:01:01,280
 and run a few commands, maybe copy, paste a file, all the usual stuff.

18
0:01:01,280 --> 0:01:04,780
 And I've been using SSH for quite some time.

19
0:01:04,780 --> 0:01:10,200
 And then three years ago, I was sitting in the pajamas camp and we were creating these

20
0:01:10,200 --> 0:01:11,600
 weird machines.

21
0:01:11,600 --> 0:01:17,280
 And then I found out you can actually make a snake game in the login prompt of SSH.

22
0:01:17,280 --> 0:01:21,040
 So that looks, yeah, this is like some time ago, that looks like this.

23
0:01:21,040 --> 0:01:26,240
 So that kind of like piqued my interest in SSH.

24
0:01:26,240 --> 0:01:29,000
 And I was like, what else can I do?

25
0:01:29,000 --> 0:01:32,200
 And just for the fun of it, let's actually try to demo it.

26
0:01:32,200 --> 0:01:36,200
 So SSH, snake, whatever.

27
0:01:36,200 --> 0:01:40,280
 And then when I log in, normally you can log in with a username and password, right?

28
0:01:40,280 --> 0:01:43,620
 You can log in with a public key where you sign something.

29
0:01:43,620 --> 0:01:45,960
 But you can also send this like challenge response.

30
0:01:46,000 --> 0:01:51,120
 I think that's pretty cool because then your challenge can just be the full game state.

31
0:01:51,120 --> 0:01:56,960
 And as you can see, I cannot actually render and see escape codes.

32
0:01:56,960 --> 0:02:00,600
 But I'm pretty sure three years ago at my setup at that time it worked.

33
0:02:00,600 --> 0:02:06,840
 So if this works for you and you don't get that weird escape code in the top, then I

34
0:02:06,840 --> 0:02:11,040
 would love to see your setup because then it should actually work for you.

35
0:02:11,040 --> 0:02:17,440
 And you can see I'm kind of just, you know, my answer to the game state is arrow down

36
0:02:17,440 --> 0:02:20,160
 and then enter and then I can play a snake.

37
0:02:20,160 --> 0:02:23,080
 And it's a bit broken, but it kind of works.

38
0:02:23,080 --> 0:02:24,160
 I think that is very cool.

39
0:02:24,160 --> 0:02:28,360
 And I kind of like building these weird machines.

40
0:02:28,360 --> 0:02:30,360
 So let me go back.

41
0:02:30,360 --> 0:02:31,760
 All right.

42
0:02:31,760 --> 0:02:34,480
 So this is the agenda.

43
0:02:34,480 --> 0:02:39,680
 As I said, for the last about three years, I've just been writing down fun, cool hacks

44
0:02:39,840 --> 0:02:46,040
 from Hacker News and so on and then try to merge them into a presentation.

45
0:02:46,040 --> 0:02:50,360
 And then two weeks ago, somebody asked me, so whenever you say SSH, you mean SSH 2.0,

46
0:02:50,360 --> 0:02:51,360
 right?

47
0:02:51,360 --> 0:02:52,360
 What is SSH 1?

48
0:02:52,360 --> 0:02:55,040
 I was like, oh, shit, I have no idea.

49
0:02:55,040 --> 0:02:57,320
 So a bit of a story also.

50
0:02:57,320 --> 0:02:58,560
 All right.

51
0:02:58,560 --> 0:02:59,880
 So who am I?

52
0:02:59,880 --> 0:03:01,520
 My name is Andy.

53
0:03:01,520 --> 0:03:06,320
 I have the domain which is a bit weird because you have to puny code it.

54
0:03:06,320 --> 0:03:10,240
 So if you see this weird xn, whatever domain, that is my domain.

55
0:03:10,240 --> 0:03:15,920
 I love doing weird hacks, making snake game as a login prompt.

56
0:03:15,920 --> 0:03:18,200
 And I also like to play capture the flag.

57
0:03:18,200 --> 0:03:24,680
 I think that's a very nice way to have a useful way or a good reason to spend three hours

58
0:03:24,680 --> 0:03:26,680
 reading an RFC.

59
0:03:26,680 --> 0:03:29,800
 Anyways, what is SSH 1.0?

60
0:03:29,800 --> 0:03:36,280
 So if you look up the spec, the SSH 2.0 spec, you find this quote saying that the best documentation

61
0:03:36,320 --> 0:03:41,360
 is in the source code of a specific client of SSH 1.0.

62
0:03:41,360 --> 0:03:47,120
 And then there's a link to an FTP server, and this is, you know, 20 years ago.

63
0:03:47,120 --> 0:03:51,000
 So I was a bit, you know, I wonder if I can find it.

64
0:03:51,000 --> 0:03:56,280
 But surprisingly, and this is why I love the internet, you just FTP into the web server,

65
0:03:56,280 --> 0:04:02,000
 and for 20 years, they have been hosting a random version of the source code of SSH 1.0

66
0:04:02,000 --> 0:04:05,080
 and drinking games going back all the way to 1993.

67
0:04:05,080 --> 0:04:07,000
 So that's fucking cool.

68
0:04:07,000 --> 0:04:10,920
 And I hope that in 20 years from now, we can still find the source code of, you know, old

69
0:04:10,920 --> 0:04:12,840
 defecated software.

70
0:04:12,840 --> 0:04:20,800
 Architecture-wise, I read a bit on SSH 1.0, but I was like, it's not so interesting.

71
0:04:20,800 --> 0:04:24,240
 And from a very high-level perspective, there's not a lot of changes.

72
0:04:24,240 --> 0:04:30,640
 Like there's, you know, another hash function, another format of input outputs and so on.

73
0:04:30,640 --> 0:04:32,680
 But that's not the fun part.

74
0:04:32,680 --> 0:04:39,440
 I think the more fun part about SSH 1.0 is kind of like, why do we have SSH 1.0?

75
0:04:39,440 --> 0:04:43,720
 And, you know, this is almost before my time, right?

76
0:04:43,720 --> 0:04:47,040
 So I don't have any memory of it.

77
0:04:47,040 --> 0:04:52,080
 But apparently before SSH, you had RSH and RCP and so on, where you could copy and paste

78
0:04:52,080 --> 0:04:59,640
 a file, and it would do what you expect it to do, just, you know, without any encryption.

79
0:04:59,640 --> 0:05:04,760
 Then came NSA and less encrypt, and today it's another time, right?

80
0:05:04,760 --> 0:05:07,360
 So of course we want to encrypt our communication.

81
0:05:07,360 --> 0:05:10,880
 So that's kind of like the main diff, let's say it like that, right?

82
0:05:10,880 --> 0:05:15,320
 You just add TLS to something else.

83
0:05:15,320 --> 0:05:19,060
 All right.

84
0:05:19,060 --> 0:05:24,320
 So let's look at SSH from an IFC perspective.

85
0:05:24,320 --> 0:05:28,560
 And if you go to the IFC spec, you see there's like three main parts of it.

86
0:05:28,560 --> 0:05:31,400
 So it's very simple, right?

87
0:05:31,400 --> 0:05:37,980
 You connect to a server, you do a key exchange stance, and then you have a secure connection

88
0:05:37,980 --> 0:05:39,240
 to the server.

89
0:05:39,240 --> 0:05:41,440
 Then you have a protocol for authentication.

90
0:05:41,440 --> 0:05:46,220
 And then finally, when you have this secure authenticated protocol, you can split that

91
0:05:46,220 --> 0:05:50,360
 into like multiple logical channels, right?

92
0:05:50,360 --> 0:05:55,280
 So you can do port for warning, you can do X11 for warning, you can have a shell.

93
0:05:55,280 --> 0:05:58,960
 I will mostly be focusing on the two top parts.

94
0:05:58,960 --> 0:06:01,080
 All right.

95
0:06:01,080 --> 0:06:07,280
 So the way I like to approach a new protocol is just to play around with it.

96
0:06:07,280 --> 0:06:10,980
 I would never start reading the IFC, I would just connect to it.

97
0:06:10,980 --> 0:06:14,480
 So what happens when you just connect to an SSH server?

98
0:06:14,480 --> 0:06:15,480
 Let's try it.

99
0:06:15,480 --> 0:06:16,480
 Right?

100
0:06:16,480 --> 0:06:17,480
 So let's kill it.

101
0:06:17,480 --> 0:06:22,840
 So netcat, my server, port 22, right?

102
0:06:22,840 --> 0:06:25,840
 So I didn't really know what to expect, right?

103
0:06:25,840 --> 0:06:31,560
 I would maybe expect a bunch of binary stuff, but actually you get a text string, and then

104
0:06:31,560 --> 0:06:36,000
 if you put something in, you get another text string out, right?

105
0:06:36,000 --> 0:06:40,200
 So I went and looked at the spec, and the spec tells you, oh, this is the format of

106
0:06:40,200 --> 0:06:41,200
 the banner, right?

107
0:06:41,200 --> 0:06:45,480
 You need to see this from the server, and then you know as a client that you can connect

108
0:06:45,480 --> 0:06:47,120
 to it.

109
0:06:47,120 --> 0:06:53,360
 And already now from a security point of view, this is something you need to pass, right?

110
0:06:53,360 --> 0:06:59,400
 You need to look at what is the maximum length of the line, also what if you get a line that

111
0:06:59,400 --> 0:07:05,400
 doesn't start with SSH 1, then the spec tells you, oh, just continue reading a line.

112
0:07:05,400 --> 0:07:11,340
 So you can set up a bunch of fun stuff, you can set up something called, like the project

113
0:07:11,340 --> 0:07:12,640
 name is awesome, right?

114
0:07:12,640 --> 0:07:13,640
 Endless SSH.

115
0:07:14,040 --> 0:07:19,440
 That just continues sending a banner forever, and then if your client doesn't time out,

116
0:07:19,440 --> 0:07:25,080
 or you stop after some amount of time, it will just continue being stuck trying to connect

117
0:07:25,080 --> 0:07:26,080
 forever, right?

118
0:07:26,080 --> 0:07:30,720
 So maybe if you all set this up, then you'll have no spammers on the internet.

119
0:07:30,720 --> 0:07:31,720
 Just kidding.

120
0:07:31,720 --> 0:07:38,080
 Another thing you can do with this is that you have these polyglot files, so you have

121
0:07:38,080 --> 0:07:43,000
 a file where if you pass it as a PNG, it's a valid PNG with stuff in the end, and if

122
0:07:43,000 --> 0:07:46,880
 you pass it as a zip file, which you pass from the bottom right, it's a valid zip file

123
0:07:46,880 --> 0:07:48,880
 with stuff in the front you just ignore.

124
0:07:48,880 --> 0:07:52,520
 And you can kind of do the same with SSH.

125
0:07:52,520 --> 0:07:57,920
 You can have an SSH server sending a banner being like I'm in an HTTP server, and if you're

126
0:07:57,920 --> 0:08:02,800
 an HTTP client, you'll just read the length of the body, and then you will stop.

127
0:08:02,800 --> 0:08:07,800
 And if you are an SSH client, you will just ignore the banner, and then you will continue

128
0:08:07,800 --> 0:08:08,800
 connecting.

129
0:08:08,800 --> 0:08:13,340
 So I tried to set that up the other day, and it works surprisingly well.

130
0:08:13,340 --> 0:08:21,160
 So if you do the same, now we can try to just curl it on port.

131
0:08:21,160 --> 0:08:22,160
 I didn't know what port to use.

132
0:08:22,160 --> 0:08:23,160
 I used 422.

133
0:08:23,160 --> 0:08:28,200
 I think that's a pretty nice port for SSH and HTTP.

134
0:08:28,200 --> 0:08:29,320
 So I curl it.

135
0:08:29,320 --> 0:08:31,600
 I get a valid reply back.

136
0:08:31,600 --> 0:08:34,080
 It's just a web server.

137
0:08:34,080 --> 0:08:42,200
 But instead of curling it, I do SSH on this port.

138
0:08:42,200 --> 0:08:53,000
 Then it's an SSH server.

139
0:08:53,000 --> 0:08:54,360
 This is not very useful, right?

140
0:08:54,360 --> 0:08:56,960
 But it's just fun to play around with the protocol.

141
0:08:56,960 --> 0:09:02,120
 And in a way, it's also a bit scary, right, because this is maybe not something that should

142
0:09:02,120 --> 0:09:03,120
 be fun to play around with.

143
0:09:03,160 --> 0:09:06,080
 It's maybe not something that should be flexible, right?

144
0:09:06,080 --> 0:09:12,640
 So I think one takeaway is if you design software like this, maybe you should be more restrictive.

145
0:09:12,640 --> 0:09:19,680
 Maybe the banner is just one line, and no infinite amount of text can just be there.

146
0:09:19,680 --> 0:09:23,760
 So yeah, polyglot, don't do that.

147
0:09:23,760 --> 0:09:28,800
 All right, but let's go back a step.

148
0:09:28,800 --> 0:09:29,800
 So I connect.

149
0:09:29,800 --> 0:09:30,800
 I get a banner.

150
0:09:30,800 --> 0:09:32,680
 I assume there's no malicious stuff.

151
0:09:32,680 --> 0:09:36,200
 How do I turn my connection into a secure connection?

152
0:09:36,200 --> 0:09:39,360
 So I do the normal development dance.

153
0:09:39,360 --> 0:09:40,800
 I generate a secret.

154
0:09:40,800 --> 0:09:44,340
 The server generates a secret, just like a number.

155
0:09:44,340 --> 0:09:48,920
 You combine the number with maybe a generator on a field, and then you get a public key.

156
0:09:48,920 --> 0:09:51,240
 The public key is random.

157
0:09:51,240 --> 0:09:52,560
 Both the public keys are random.

158
0:09:52,560 --> 0:09:54,640
 You have a secret.

159
0:09:54,640 --> 0:09:58,320
 You send only the public keys.

160
0:09:58,520 --> 0:10:05,880
 And then if you have a passive attacker, they can only see the public keys, and you cannot

161
0:10:05,880 --> 0:10:07,000
 turn the public key.

162
0:10:07,000 --> 0:10:12,440
 You have to combine a secret key with a public key to turn it into the shared secret.

163
0:10:12,440 --> 0:10:17,360
 So with this setup, we know that any passive attackers will be defeated, but there could

164
0:10:17,360 --> 0:10:20,500
 be an active attacker just replacing the key.

165
0:10:20,500 --> 0:10:26,520
 And in this case, I basically only get a secure connection between me and somebody, right?

166
0:10:26,520 --> 0:10:32,320
 Me and an active attacker, or me or the actual server.

167
0:10:32,320 --> 0:10:43,720
 So what happens afterwards is the server will take its other public key and sign this transaction.

168
0:10:43,720 --> 0:10:49,560
 And then the server can prove to me that whatever random public key I get is actually signed

169
0:10:49,560 --> 0:10:52,400
 by the actual server key.

170
0:10:52,400 --> 0:10:56,440
 But how do I trust the actual server key?

171
0:10:56,480 --> 0:10:59,320
 So there's a pretty nice quote from the RFC.

172
0:10:59,320 --> 0:11:03,520
 This is from, I think it's from 2006 or something, right?

173
0:11:03,520 --> 0:11:09,200
 So it tells you this whole, you need to map a server name into a public key.

174
0:11:09,200 --> 0:11:10,680
 And how do you do that?

175
0:11:10,680 --> 0:11:15,880
 Well, I mean, you can have a database of public keys, the known host file.

176
0:11:15,880 --> 0:11:21,400
 You can use a certificate authority set up like we do with TILUS, or you can trust the

177
0:11:21,400 --> 0:11:23,600
 key on first use, which is what we normally do.

178
0:11:23,640 --> 0:11:27,480
 We see a random key, just do like, yes, I believe this key is good.

179
0:11:27,480 --> 0:11:31,520
 And then you save the hash of the key for next time.

180
0:11:31,520 --> 0:11:35,680
 But then the spec tells us like, oh, but at some point in the future, of course, somebody

181
0:11:35,680 --> 0:11:41,840
 will create a widely deployed key infrastructure that we can just use.

182
0:11:41,840 --> 0:11:47,600
 And this is, again, like 20 years ago, and we don't really have a good PKI, or do we?

183
0:11:47,600 --> 0:11:51,320
 So I'm probably not be very popular in this sense.

184
0:11:51,360 --> 0:11:54,680
 But we actually do have a widely deployed PKI.

185
0:11:54,680 --> 0:11:59,840
 We have DNSSEC, which everybody loves to hate, but it's actually a pretty cool setup.

186
0:11:59,840 --> 0:12:07,160
 So if my domain name is signed by DNS, and I put my public key in DNS, then I can just

187
0:12:07,160 --> 0:12:09,000
 distribute it.

188
0:12:09,000 --> 0:12:12,360
 And there's a spec for that.

189
0:12:12,360 --> 0:12:13,800
 And the format is fairly simple, right?

190
0:12:13,800 --> 0:12:20,200
 You have a dedicated DNS record where you put in the algorithm of the key and then the

191
0:12:20,280 --> 0:12:23,960
 type of the fingerprint.

192
0:12:23,960 --> 0:12:29,640
 I would say I read a lot of the spec, and the SSH is very flexible.

193
0:12:29,640 --> 0:12:33,640
 Like, whenever you can have multiple types, you will be able to have multiple types, right?

194
0:12:33,640 --> 0:12:35,640
 It's never just hash it with this algorithm.

195
0:12:35,640 --> 0:12:40,440
 It's always have a type of the hash, and then you know, yeah.

196
0:12:40,440 --> 0:12:42,320
 So stuff is a bit complicated, right?

197
0:12:42,320 --> 0:12:47,480
 But this is how it looked originally on my setup, right?

198
0:12:47,480 --> 0:12:49,080
 So I have my domain name.

199
0:12:49,080 --> 0:12:54,200
 I have multiple keys on my server because that's the default.

200
0:12:54,200 --> 0:13:03,440
 Then I pick one of the keys, host, DSA, whatever, I hash it, and then I put in the hash in DNS.

201
0:13:03,440 --> 0:13:08,480
 Then in my local config, I can say, please look up DNS, make sure that the DNS record

202
0:13:08,480 --> 0:13:13,200
 is authenticated, and then stuff should just work without the known host file and no trust

203
0:13:13,200 --> 0:13:14,560
 on first use.

204
0:13:14,560 --> 0:13:17,320
 So let's try that.

205
0:13:17,320 --> 0:13:29,120
 And my domain name.

206
0:13:29,120 --> 0:13:33,720
 So first of all, you'll see I don't have like many keys left.

207
0:13:33,720 --> 0:13:37,840
 I only have like a single key, and I think that's a very sane default.

208
0:13:37,840 --> 0:13:44,880
 Like just if you don't need, I think by default, you know, your SSH server, whatever will come

209
0:13:45,000 --> 0:13:49,080
 with like multiple keys of types and so on, you know, just delete the three of them and

210
0:13:49,080 --> 0:13:50,640
 see if it still works.

211
0:13:50,640 --> 0:13:56,040
 So in this case, I'm using a type four key, which I think when I took the screenshot was

212
0:13:56,040 --> 0:13:57,420
 not a thing.

213
0:13:57,420 --> 0:14:01,880
 So it's still a very evolving setup.

214
0:14:01,880 --> 0:14:08,200
 So this is like one of these fancy ED25519 keys.

215
0:14:08,200 --> 0:14:10,240
 And then you see I have a hash of the key.

216
0:14:10,240 --> 0:14:19,280
 So if I go to my SSH folder and my known host, this one, and just kill it, right?

217
0:14:19,280 --> 0:14:23,400
 Then now I have no idea about any server fingerprints.

218
0:14:23,400 --> 0:14:31,400
 But if I try to log into my website, then hopefully, okay, then it doesn't work because

219
0:14:31,400 --> 0:14:39,760
 I don't have my key at it.

220
0:14:39,760 --> 0:14:47,880
 So I have another demo later.

221
0:14:47,880 --> 0:14:48,880
 Demo gods, please.

222
0:14:48,880 --> 0:14:56,040
 What is my password?

223
0:14:56,040 --> 0:14:57,040
 Is it not that one?

224
0:14:57,040 --> 0:14:58,040
 It should be that one.

225
0:14:58,040 --> 0:15:18,440
 Okay, I know my password is, okay, awesome.

226
0:15:18,440 --> 0:15:23,660
 So what I'm trying to do, I'm trying to SSH in the right, but I have no idea what the

227
0:15:23,660 --> 0:15:25,160
 fingerprint should be.

228
0:15:25,160 --> 0:15:27,760
 And hopefully, it's a bit slow.

229
0:15:27,760 --> 0:15:28,760
 I'll get in.

230
0:15:28,760 --> 0:15:29,760
 Right?

231
0:15:29,760 --> 0:15:31,960
 So that is pretty awesome.

232
0:15:31,960 --> 0:15:40,000
 And what happens if you try to then authenticate to something without a fingerprint in DNS?

233
0:15:40,000 --> 0:15:42,640
 Let's take this one.

234
0:15:42,640 --> 0:15:48,280
 Then you'll get the normal, you know, prompt saying here's a fingerprint of this server's

235
0:15:48,280 --> 0:15:49,280
 key.

236
0:15:49,280 --> 0:15:50,280
 I have no idea.

237
0:15:50,280 --> 0:15:51,600
 Do you want to trust on first use?

238
0:15:51,600 --> 0:15:54,600
 I can be yes, no, whatever.

239
0:15:54,600 --> 0:16:04,520
 And what happens if I try to log into a broken setup?

240
0:16:04,520 --> 0:16:09,480
 Then I'll get this big fat warning saying, you know, I actually found a fingerprint.

241
0:16:09,480 --> 0:16:10,840
 And the fingerprint is wrong, right?

242
0:16:10,840 --> 0:16:13,200
 So like an even bigger error message.

243
0:16:13,200 --> 0:16:19,920
 But I think this is a nice setup because if you manage a lot of servers, at least in my

244
0:16:20,560 --> 0:16:25,400
 experience, every now and then you might change the key for various reasons or you might lose

245
0:16:25,400 --> 0:16:27,480
 your known host file or whatnot.

246
0:16:27,480 --> 0:16:33,440
 So it is, instead of just being yes, then try to put it in DNS.

247
0:16:33,440 --> 0:16:36,440
 It's pretty cool.

248
0:16:36,440 --> 0:16:40,120
 All right.

249
0:16:40,120 --> 0:16:43,840
 Okay.

250
0:16:43,840 --> 0:16:45,620
 So what is the requirement, right?

251
0:16:45,620 --> 0:16:53,980
 You need a DNS provider that supports this very specific record type, right, SSH, FP.

252
0:16:53,980 --> 0:16:55,820
 So that's a bit annoying.

253
0:16:55,820 --> 0:16:57,740
 Then you need to trust DNS, right?

254
0:16:57,740 --> 0:17:02,340
 So you need DNS on your domain and on your clients.

255
0:17:02,340 --> 0:17:09,300
 And then I don't know how many people used Gratis DNS, but they changed to One.com.

256
0:17:09,300 --> 0:17:13,020
 And One.com did not support SSH FP.

257
0:17:13,020 --> 0:17:18,020
 And this change occurred while I was testing around and changing my key.

258
0:17:18,020 --> 0:17:21,900
 So I was stuck with this, you know, forever warning because I cannot change my DNS record

259
0:17:21,900 --> 0:17:26,700
 because I'm stuck on a provider that does not support it and I'm using a new key.

260
0:17:26,700 --> 0:17:28,620
 That was a bit annoying.

261
0:17:28,620 --> 0:17:31,780
 But anyways, they support it now, which is pretty cool.

262
0:17:31,780 --> 0:17:33,260
 All right.

263
0:17:33,260 --> 0:17:36,460
 So going back a bit, right?

264
0:17:36,460 --> 0:17:37,660
 So I'm connected to a server.

265
0:17:37,660 --> 0:17:39,300
 We're doing the Diffie-Heldman dance.

266
0:17:39,300 --> 0:17:42,940
 I'm trusting the key because I have some way of trusting it.

267
0:17:43,660 --> 0:17:53,380
 So I have a shared secret, the stuff below in the bottom of the picture.

268
0:17:53,380 --> 0:17:58,700
 So for some of the next slides, I just have some stuff I like about SSH and some stuff

269
0:17:58,700 --> 0:17:59,700
 I don't like.

270
0:17:59,700 --> 0:18:02,980
 So what I like is they have this exchange hash.

271
0:18:02,980 --> 0:18:06,260
 So the key, of course, you never would, don't ever share that, right?

272
0:18:06,260 --> 0:18:08,820
 Don't put it in log files, don't do stuff like that.

273
0:18:08,820 --> 0:18:11,600
 But you would love to have a way to reference to the key.

274
0:18:11,600 --> 0:18:13,960
 So it's a very simple protocol setup, right?

275
0:18:13,960 --> 0:18:18,400
 You just be like, here's the key, that secret has the key, and then this is public.

276
0:18:18,400 --> 0:18:24,200
 I think that's a pretty nice setup because then you can refer to this temporary setup

277
0:18:24,200 --> 0:18:25,480
 we have.

278
0:18:25,480 --> 0:18:30,000
 Then next, we kind of want to split this key into multiple keys.

279
0:18:30,000 --> 0:18:36,040
 And what SSH does is it just hashes together this secret key with the letter A, the letter

280
0:18:36,040 --> 0:18:37,920
 B, the letter C, and so on.

281
0:18:37,920 --> 0:18:39,520
 I kind of like this setup.

282
0:18:39,520 --> 0:18:41,520
 It's pretty simple.

283
0:18:41,520 --> 0:18:47,200
 Probably, like, if you should design a new SSH 3.0, whatever, you should use a real key

284
0:18:47,200 --> 0:18:49,040
 duration function.

285
0:18:49,040 --> 0:18:54,080
 But I mean, this is a pretty neat, easy setup.

286
0:18:54,080 --> 0:18:55,400
 But there's something a bit weird, right?

287
0:18:55,400 --> 0:18:57,520
 Why do I need so many keys?

288
0:18:57,520 --> 0:18:59,040
 It's quite a lot of keys.

289
0:18:59,040 --> 0:19:00,400
 And that's the next thing, right?

290
0:19:00,400 --> 0:19:06,120
 So the spec tells you you need to, like, you do have a secure connection, you have a bunch

291
0:19:06,120 --> 0:19:12,360
 of packages with the control messages going back and forth, and then you agree on should

292
0:19:12,360 --> 0:19:17,000
 we compress data, which type of cipher should we use, and so on.

293
0:19:17,000 --> 0:19:21,640
 And the spec tells you you must be able to, you know, independently of the direction,

294
0:19:21,640 --> 0:19:26,120
 change the selected cipher and compression, and so on.

295
0:19:26,120 --> 0:19:30,880
 So it's perfectly valid for me to send compressed AES to my server and then get uncompressed

296
0:19:30,880 --> 0:19:35,080
 DES encrypted data back, and that's super, super weird.

297
0:19:35,080 --> 0:19:37,840
 But it's valid SSH.

298
0:19:37,840 --> 0:19:41,960
 So again, I would love to see this being removed from the spec, just so you know, it should

299
0:19:41,960 --> 0:19:42,960
 be the same.

300
0:19:42,960 --> 0:19:47,040
 I should never want to use one cipher going to my server and then another cipher going

301
0:19:47,040 --> 0:19:48,520
 back.

302
0:19:48,520 --> 0:19:50,560
 Okay.

303
0:19:50,560 --> 0:19:54,800
 So I can encrypt data, but how do I know somebody is not going to just do random bit

304
0:19:54,800 --> 0:19:55,800
 flips, right?

305
0:19:55,800 --> 0:19:58,400
 AES does not protect against bit flips.

306
0:19:58,400 --> 0:20:01,560
 At least, you know, I can do some stuff with it.

307
0:20:01,560 --> 0:20:11,880
 So the underlying protocol is called the binary package protocol in SSH.

308
0:20:11,880 --> 0:20:17,740
 And the format is quite simple, it's, you know, you encrypt some data, and then you

309
0:20:17,740 --> 0:20:25,000
 have a message authentication code giving you integrity after the encrypted data.

310
0:20:25,000 --> 0:20:29,800
 And then, you know, this inner package is just, you know, the length of the package,

311
0:20:29,800 --> 0:20:36,400
 the length of some padding, and then the package and then the padding looks like this.

312
0:20:36,400 --> 0:20:40,760
 And this is a very weird setup, because how do we parse it?

313
0:20:40,760 --> 0:20:45,960
 So you get some ciphertext, but you maybe don't know how much ciphertext you need.

314
0:20:45,960 --> 0:20:50,440
 And the only way to figure out is if you decrypt the first block.

315
0:20:50,440 --> 0:20:54,560
 And then you can, after you have decrypted the first block of the ciphertext, you can

316
0:20:54,560 --> 0:20:59,260
 figure out I need to read a few more packages, and then you can check the Mac.

317
0:20:59,260 --> 0:21:07,180
 So that means I can now do, I can start tampering with the first part of whatever this is, right?

318
0:21:07,180 --> 0:21:10,860
 Because you have no idea how to check it without just decrypting it.

319
0:21:10,860 --> 0:21:16,060
 And then you can do these kind of like active attack against the cipher.

320
0:21:16,060 --> 0:21:22,820
 For instance, if I want to decrypt a package that contains all F, or I believe it's like

321
0:21:22,820 --> 0:21:28,760
 FFFF, and I put that as the first package, and you decrypt it, and you figure out, oh,

322
0:21:28,760 --> 0:21:31,320
 so the length must be FFFF.

323
0:21:31,320 --> 0:21:40,040
 So you just continue reading data from the wire until you get FFFFF data, which, of course,

324
0:21:40,040 --> 0:21:42,440
 won't happen, right?

325
0:21:42,440 --> 0:21:47,840
 But if it's 0, 0, 0, 0, then you know that there should be no more data, so you can check

326
0:21:47,840 --> 0:21:50,440
 the Mac, the Mac will fail, and you close the connection.

327
0:21:50,440 --> 0:21:57,800
 So now you can do these attacks where you can at least guess some stuff from the cipher.

328
0:21:57,800 --> 0:22:04,720
 This is called encryption and macking, and it's a bit kind of like, I would say, 2,000

329
0:22:04,720 --> 0:22:07,960
 wipes, where you didn't really know how to do it, right?

330
0:22:07,960 --> 0:22:12,680
 There's also encryption, then macking, which is almost the same.

331
0:22:12,680 --> 0:22:16,600
 What you should do is called, sorry, Mac, then encrypt.

332
0:22:16,600 --> 0:22:19,680
 What you should do is encrypt the Mac, ETM.

333
0:22:19,680 --> 0:22:26,760
 And in ETM, you just do the order a bit different, but now you need to, now you can check the

334
0:22:26,760 --> 0:22:29,840
 Mac before you even try to decrypt data.

335
0:22:29,840 --> 0:22:32,560
 But this requires the length to be public, right?

336
0:22:32,560 --> 0:22:34,700
 But the length is already a bit public, right?

337
0:22:34,700 --> 0:22:39,560
 Because you already need to know, if you are an attacker, you can just look at the length

338
0:22:39,560 --> 0:22:43,000
 of the encrypted data on the wire.

339
0:22:43,000 --> 0:22:45,960
 So it doesn't really leak anything.

340
0:22:45,960 --> 0:22:52,360
 And if you want to enable this, then you can configure your server and your client to accept

341
0:22:52,360 --> 0:22:55,240
 only cipher's ending with ETM.

342
0:22:55,240 --> 0:22:59,560
 So you'll also see that in my config later, that you can just go in and enable this, right?

343
0:22:59,560 --> 0:23:07,920
 So this is an OpenSSH extension, so it's not part of the original spec, but it's a much

344
0:23:07,920 --> 0:23:13,960
 better way of doing it.

345
0:23:13,960 --> 0:23:19,520
 So there's another, like a cool trick, actually, SSH does, which is that the Mac is not only

346
0:23:19,520 --> 0:23:23,940
 the, I was lying a bit here, but it's not only the inner part of the message.

347
0:23:23,940 --> 0:23:29,860
 It's actually a sequence number and then the inner part of the message.

348
0:23:29,860 --> 0:23:34,700
 And the sequence number is not sent over the wire, but it's just your counter going up.

349
0:23:34,700 --> 0:23:39,460
 And the idea here is that if you reorder packages, then the sequence number will be incorrect.

350
0:23:39,460 --> 0:23:43,220
 And then you can detect somebody reordering packages.

351
0:23:43,220 --> 0:23:49,880
 So this is pretty neat, but I read a lot of, you know, message threads about people being

352
0:23:49,880 --> 0:23:54,000
 a bit annoyed because it also means that the input to the Mac function is not the same

353
0:23:54,000 --> 0:23:56,180
 as the input to the encryption function.

354
0:23:56,180 --> 0:24:01,840
 So if you want to replace all of this with just AES in GCM mode, which is authenticated,

355
0:24:01,840 --> 0:24:06,680
 then you have this, you know, a bit annoying thing where you need to, you're not encrypting

356
0:24:06,680 --> 0:24:09,440
 the same stuff as what you're actually checking.

357
0:24:09,440 --> 0:24:12,120
 It's not an issue, it's just a bit annoying.

358
0:24:12,120 --> 0:24:15,560
 So yeah, somebody spent a long time on that.

359
0:24:15,560 --> 0:24:16,800
 All right.

360
0:24:16,800 --> 0:24:19,720
 So I have a way to connect to a server.

361
0:24:19,720 --> 0:24:24,000
 The server, we agree with, we generate a secure channel.

362
0:24:24,000 --> 0:24:29,400
 I can authenticate that the server is actually who it tells me it is.

363
0:24:29,400 --> 0:24:31,320
 But the server have no idea who I am.

364
0:24:31,320 --> 0:24:35,760
 So you need to now go to the next step, the authentication protocol.

365
0:24:35,760 --> 0:24:41,720
 And in the authentication protocol, you select like a method and there's, of course, a few

366
0:24:41,720 --> 0:24:45,200
 more in later extensions.

367
0:24:45,200 --> 0:24:50,400
 What I find pretty fun is that password authentication is not required.

368
0:24:50,400 --> 0:24:55,560
 So it's valid, again, to be an SSH server and be like, no, I don't want to do passwords.

369
0:24:55,560 --> 0:24:56,560
 I think that's pretty cool.

370
0:24:56,560 --> 0:25:01,800
 I guess most people, the first time you use SSH, you just have a username and password.

371
0:25:01,800 --> 0:25:05,920
 But actually, you can be like, I only want to support public keys.

372
0:25:05,920 --> 0:25:10,040
 Another thing is you can also have a non-method, so you can just connect to a server, be like,

373
0:25:10,040 --> 0:25:14,280
 I'm rude and I don't need to authenticate who I am.

374
0:25:14,280 --> 0:25:17,100
 Of course, the server is not going to allow that, right?

375
0:25:17,100 --> 0:25:23,000
 But it is technically valid for the server to be like, okay, I guess.

376
0:25:23,000 --> 0:25:25,280
 And then, yeah.

377
0:25:25,280 --> 0:25:27,080
 Let's see.

378
0:25:27,080 --> 0:25:29,460
 Oh, wait a minute.

379
0:25:29,460 --> 0:25:35,720
 So you have this ping pong flow where you get a list of the server can tell you, oh,

380
0:25:35,720 --> 0:25:39,240
 but you need public key and the passwords.

381
0:25:39,240 --> 0:25:46,120
 For the snake game I did initially, you have this challenge response method.

382
0:25:46,120 --> 0:25:52,520
 And for every reply you get from the server, the server can tell you that you had a partially

383
0:25:52,520 --> 0:25:56,240
 success when you logged in.

384
0:25:56,240 --> 0:26:01,660
 So for instance, you'd be like, I would like to log in with this username and password.

385
0:26:01,660 --> 0:26:06,360
 You log in and then the server is like, that's good, but you need to prove a bit more.

386
0:26:06,360 --> 0:26:13,240
 So you can also use this to have two-factor when you log in.

387
0:26:13,240 --> 0:26:16,880
 Of course, if you do two-factor, you should also have some kind of rate limits, right?

388
0:26:16,880 --> 0:26:20,680
 Because it's very easy to boot for us otherwise.

389
0:26:20,680 --> 0:26:25,480
 And this is the request you sign if you use a public key.

390
0:26:25,480 --> 0:26:27,160
 It's fairly simple, right?

391
0:26:27,160 --> 0:26:35,000
 You put in, I would like to do, like, the service name is, I think, the difference between

392
0:26:35,000 --> 0:26:38,040
 the X11 for warding and just a shell.

393
0:26:38,040 --> 0:26:41,160
 You put in your username, then you put in your session identifier.

394
0:26:41,160 --> 0:26:46,120
 That's the public part of the shared secret from before.

395
0:26:46,120 --> 0:26:47,120
 So that's pretty cool.

396
0:26:47,120 --> 0:26:55,440
 That kind of binds this signature to the channel I have right now that is generated uniquely

397
0:26:55,440 --> 0:26:57,800
 to this session.

398
0:26:57,800 --> 0:27:00,920
 And then I put my public key and that's it.

399
0:27:01,480 --> 0:27:06,320
 That's like one field missing from this one, which is not part of the spec, but it would

400
0:27:06,320 --> 0:27:08,440
 have made the spec so much nicer.

401
0:27:08,440 --> 0:27:16,000
 So I'm only signing that I'm now connecting to whatever this is.

402
0:27:16,000 --> 0:27:20,880
 But if I connect to one server and from that server I'd like to connect to another server

403
0:27:20,880 --> 0:27:26,120
 and to another server and to another server, then these, which is agent for warding, we'll

404
0:27:26,160 --> 0:27:32,520
 talk about later, then all these signatures, they will be signed by my key on my laptop,

405
0:27:32,520 --> 0:27:33,680
 but I don't know what I'm assigning.

406
0:27:33,680 --> 0:27:36,880
 I'm just assigning random session identifiers.

407
0:27:36,880 --> 0:27:41,600
 So the other servers along the way, they can just be like, okay, you would like to connect

408
0:27:41,600 --> 0:27:42,600
 to GitHub.

409
0:27:42,600 --> 0:27:43,960
 Yes, just sign this signature.

410
0:27:43,960 --> 0:27:49,520
 And then they actually are in the process of connecting to an internal server or whatnot.

411
0:27:49,520 --> 0:27:54,960
 So this would have been much nicer if you had the public key of who you are actually

412
0:27:54,960 --> 0:27:56,520
 connecting to.

413
0:27:56,520 --> 0:27:59,600
 All right.

414
0:27:59,600 --> 0:28:06,520
 And then there's a pretty nice project by a guy called Filippo, who has scraped all

415
0:28:06,520 --> 0:28:08,400
 public GitHub keys.

416
0:28:08,400 --> 0:28:15,480
 And then when you log into the server, I'll send my key, whoops, that one, like the key

417
0:28:15,480 --> 0:28:16,680
 in the bottom of it.

418
0:28:16,680 --> 0:28:18,800
 And then he can just do a reverse lookup.

419
0:28:18,800 --> 0:28:21,400
 So this key must be somebody.

420
0:28:21,400 --> 0:28:23,480
 And that works quite well.

421
0:28:23,480 --> 0:28:26,080
 Let's try it.

422
0:28:40,080 --> 0:28:42,320
 Yes, I'd like to connect.

423
0:28:42,320 --> 0:28:51,320
 And then, and he can look up that the key I have is connected to my GitHub, right?

424
0:28:51,760 --> 0:28:54,720
 So that's very revealing.

425
0:28:54,720 --> 0:28:57,800
 And you can actually also do the opposite, which is pretty cool.

426
0:28:57,800 --> 0:29:06,680
 So when you connect to an SSH server, you can send a list of public keys.

427
0:29:06,680 --> 0:29:11,320
 And then you can ask the server which of these public keys works for this user on this account,

428
0:29:11,320 --> 0:29:14,040
 on this system.

429
0:29:14,040 --> 0:29:18,280
 And then the server can reply back saying, oh, the third key works.

430
0:29:18,280 --> 0:29:24,480
 And the reason you can do that is because, let's say you have a physical hardware key

431
0:29:24,480 --> 0:29:26,320
 you need to click to use.

432
0:29:26,320 --> 0:29:31,520
 Then you don't want the user to click a bunch of hardware keys to find the right key that

433
0:29:31,520 --> 0:29:33,560
 actually works.

434
0:29:33,560 --> 0:29:40,880
 But it also means that, let's say I want to reveal some kind of a hidden service.

435
0:29:40,880 --> 0:29:45,360
 Then I might, as I say, send to the hidden service, and then I might just start from

436
0:29:45,440 --> 0:29:49,560
 the beginning of all the GitHub keys and try, like, can this key authenticate?

437
0:29:49,560 --> 0:29:51,020
 Can this key authenticate?

438
0:29:51,020 --> 0:29:56,720
 And then maybe I'll find a key and then I can look up that somebody has access to a

439
0:29:56,720 --> 0:30:01,720
 tool, might have access to a hidden service, like a public name.

440
0:30:01,720 --> 0:30:06,680
 So that's, I think that's also a bit of a, I don't know if I like it or if I don't like

441
0:30:06,680 --> 0:30:07,760
 it as part of the spec.

442
0:30:07,760 --> 0:30:12,320
 I understand the idea, but I think it's a bit weird that you can actually query a server.

443
0:30:12,320 --> 0:30:15,920
 The server can, of course, just lie, say, like, no, none of the key works.

444
0:30:15,920 --> 0:30:20,880
 But then if you actually use the key, it will work.

445
0:30:20,880 --> 0:30:22,680
 All right.

446
0:30:22,680 --> 0:30:31,400
 So if I SSH from my system into another system, and then I would like to SSH from that other

447
0:30:31,400 --> 0:30:37,560
 system and further along the way, then I probably don't want to copy paste my keys around.

448
0:30:37,560 --> 0:30:45,880
 So I can use something called agent forwarding, and let's actually test that.

449
0:30:45,880 --> 0:30:56,720
 So I have a demo system.

450
0:30:56,720 --> 0:31:05,640
 On the demo system, I start an SSH agent.

451
0:31:05,640 --> 0:31:12,360
 Then in my agent, I add one of my keys.

452
0:31:12,360 --> 0:31:15,360
 So now it's basically just a background process, right?

453
0:31:15,360 --> 0:31:42,240
 Then if I, from this system, SSH into, a moment, to this system.

454
0:31:42,240 --> 0:31:46,960
 Okay.

455
0:31:46,960 --> 0:31:53,600
 So I'm, you know, from one system jumping into another system, no, sorry, and I'm forwarding

456
0:31:53,600 --> 0:31:56,560
 my agent.

457
0:31:56,560 --> 0:32:04,400
 Then from the terminal in the bottom, I'll jump to the second system directly.

458
0:32:04,400 --> 0:32:13,380
 And from this system, I'm going to look at which file are in temp.

459
0:32:13,380 --> 0:32:14,380
 So that's it.

460
0:32:14,380 --> 0:32:18,060
 Few files, but nothing important, right?

461
0:32:18,060 --> 0:32:24,200
 So from the top system, the demo box, I'm jumping into the Hexner box, and from the

462
0:32:24,200 --> 0:32:28,880
 Hexner box, I now have an forwarded agent.

463
0:32:28,880 --> 0:32:34,960
 So if I look at attempt again, I should be able to see an SSH folder.

464
0:32:34,960 --> 0:32:44,040
 And if I go to that folder, then I can see that there is a socket available.

465
0:32:44,040 --> 0:32:50,680
 So if I write something to this socket, it will be forwarded back through the SSH connection

466
0:32:50,680 --> 0:32:53,920
 back to the original box.

467
0:32:53,920 --> 0:32:55,320
 And this is very dangerous, right?

468
0:32:55,320 --> 0:33:01,160
 Because if I'm root on the bottom window, then I, of course, have access to the socket,

469
0:33:01,160 --> 0:33:02,160
 right?

470
0:33:02,160 --> 0:33:06,080
 The socket can only be protected by whoever the first user is.

471
0:33:06,080 --> 0:33:11,920
 So that means that I can now, from the bottom, from the attacker's point of view, I can just

472
0:33:11,920 --> 0:33:20,600
 ask the socket to sign a request on the behalf of the first user.

473
0:33:21,160 --> 0:33:27,040
 So the demo is a bit boring, because you just set an environment variable, and then you

474
0:33:27,040 --> 0:33:29,920
 use all the normal SSH tools.

475
0:33:29,920 --> 0:33:31,880
 So I'm not going to demo it.

476
0:33:31,880 --> 0:33:40,200
 But what is cool is that in very new versions of OpenSSH, you can actually use something

477
0:33:40,200 --> 0:33:43,840
 called agent restriction.

478
0:33:43,840 --> 0:33:48,200
 The problem is agent restrictions require changes to all of your binaries, right?

479
0:33:48,200 --> 0:33:52,200
 Like your SSH agent, SSH add, and SSH daemon.

480
0:33:52,200 --> 0:33:56,640
 But if you have these newer versions, then you can specify a conflict like this.

481
0:33:56,640 --> 0:34:01,640
 When I added, before when I added the key, I just added to the agent, you know, this

482
0:34:01,640 --> 0:34:05,120
 key is available for everybody to do basically everything, right?

483
0:34:05,120 --> 0:34:08,720
 Sign stuff on my regard.

484
0:34:08,720 --> 0:34:13,160
 With this new setup, I can tell the agent, when you get a request to sign something,

485
0:34:13,160 --> 0:34:15,360
 you should actually check what you're signing.

486
0:34:15,360 --> 0:34:20,880
 So in this case, I'm saying if I'm trying to, so like a common case, I think, would

487
0:34:20,880 --> 0:34:27,880
 be I'm often SSHing into my server, and for my server, I would like to SSH into GitHub,

488
0:34:27,880 --> 0:34:29,720
 because I have my stuff on GitHub, right?

489
0:34:29,720 --> 0:34:34,900
 But I don't want to copy my file, my private key to my server.

490
0:34:34,900 --> 0:34:43,240
 So it would be nice just to be, to add the restriction that the agent must only sign

491
0:34:43,360 --> 0:34:49,920
 the user git on the domain git.data.coop, for instance.

492
0:34:49,920 --> 0:34:54,680
 And if you go back like a ton of slides, you see that that's not possible with this format.

493
0:34:54,680 --> 0:34:58,440
 So you need to change the format, but I can only check the user name, because this is

494
0:34:58,440 --> 0:35:03,800
 the request I'm getting on my agent to sign.

495
0:35:03,800 --> 0:35:09,240
 But with this new setup, you know, there are some changes to what I'm actually signing,

496
0:35:09,240 --> 0:35:12,900
 which is why you need all the changes in the binaries.

497
0:35:12,940 --> 0:35:17,140
 But then you can actually, you know, change these things.

498
0:35:17,140 --> 0:35:21,860
 Another kind of like implementation detail is that it doesn't really make sense to restrict

499
0:35:21,860 --> 0:35:29,480
 stuff on a hostname basis, because one key can have multiple hostnames, or how do I kind

500
0:35:29,480 --> 0:35:30,660
 of like check that?

501
0:35:30,660 --> 0:35:36,180
 So what actually happens behind the scenes is that SSH add will look up what is the host

502
0:35:36,180 --> 0:35:41,180
 key of all these domains, and then add the restriction there.

503
0:35:42,980 --> 0:35:43,980
 Right?

504
0:35:43,980 --> 0:35:48,620
 This is fun and awesome, but it's very new, so it might not work, but if you can use it,

505
0:35:48,620 --> 0:35:53,220
 then you should absolutely restrict stuff if you're going to forward your agent.

506
0:35:53,220 --> 0:35:58,360
 And then you should absolutely only forward your agent if you must, because it's very

507
0:35:58,360 --> 0:36:06,700
 dangerous because if somebody can attack the server you're SSHing into, then they can just

508
0:36:06,700 --> 0:36:08,860
 ask your agent to sign anything.

509
0:36:08,860 --> 0:36:09,960
 All right.

510
0:36:09,960 --> 0:36:18,720
 So that's kind of like the first part of the presentation, and then let's go through some

511
0:36:18,720 --> 0:36:20,960
 other random notes.

512
0:36:20,960 --> 0:36:26,640
 First is, if you're using an ISA key, which you might be, because that's the standard,

513
0:36:26,640 --> 0:36:36,080
 then don't, this is ugly as fuck, instead you should generate a new key of type in elliptic

514
0:36:36,080 --> 0:36:38,040
 curve key if you can.

515
0:36:38,040 --> 0:36:43,600
 You get the same security level, it's just much smaller, which is very cool, and often

516
0:36:43,600 --> 0:36:46,520
 it's much easier to actually implement.

517
0:36:46,520 --> 0:36:49,240
 So absolutely do that.

518
0:36:49,240 --> 0:36:57,160
 Next, you can do some pretty neat stuff with FIDO keys, like USB sticks, but also if you

519
0:36:57,160 --> 0:37:01,160
 have the mid-ID device, you can also use that.

520
0:37:01,160 --> 0:37:06,400
 I forgot it, so I cannot show a demo with it.

521
0:37:06,400 --> 0:37:16,600
 One bit of annoyance is that often you cannot ask your FIDO key to be in the ED255.19 format,

522
0:37:16,600 --> 0:37:25,440
 which is the nicest by far, but you can often use ECDSA instead, which is almost the same,

523
0:37:25,440 --> 0:37:31,440
 just sucks a bit more, but it's probably missed whatever certifies it works.

524
0:37:31,480 --> 0:37:37,600
 The key will look like this when you generate it, so it has like SK, I think that stands

525
0:37:37,600 --> 0:37:39,640
 for security key, maybe.

526
0:37:39,640 --> 0:37:44,000
 The key is very long, because it actually contains a proof that, or it can contain a

527
0:37:44,000 --> 0:37:52,200
 proof that it was signed on some hardware, so they are a bit long and annoying.

528
0:37:52,200 --> 0:37:58,120
 You can also, I think, include in the key if you need to physically click on the key

529
0:37:58,120 --> 0:38:02,920
 to sign the request, or if you can just send the request to the key and then it will automatically

530
0:38:02,920 --> 0:38:03,920
 sign.

531
0:38:03,920 --> 0:38:09,600
 I was hoping that when they implemented this, they would do some kind of fancy, how do we

532
0:38:09,600 --> 0:38:16,720
 cheat the key, because the FIDO2 standard is not very, that's meant for browsers, right?

533
0:38:16,720 --> 0:38:20,920
 How do you merge SSH into that?

534
0:38:20,920 --> 0:38:25,160
 They're not doing anything fancy, like trying to get the key to believe that it's actually

535
0:38:25,200 --> 0:38:32,440
 signing a web request, but it's an open SSH request, they're just telling the key what

536
0:38:32,440 --> 0:38:35,360
 I showed before what you're signing, you're signing something completely different if

537
0:38:35,360 --> 0:38:40,480
 you're using one of these keys, so that's not very fun.

538
0:38:40,480 --> 0:38:48,600
 You can most likely also use a TPM, which is very cool, so I think this is from Ledger,

539
0:38:48,600 --> 0:38:52,920
 the Bitcoin, Crypto, whatever company, they have actually been pushing pretty hard for

540
0:38:52,920 --> 0:39:00,280
 this, so the TPM standard is apparently very new, there's a tool called TPM2PKCS11, which

541
0:39:00,280 --> 0:39:06,960
 is like the talk to a smart card standard, and it is most likely in your distro today,

542
0:39:06,960 --> 0:39:13,240
 so I tried it before, and it worked super nice, and that's why my key was winning.

543
0:39:13,240 --> 0:39:22,160
 So let's see, go back here, so in this demo, I have no identities added to my SSH agent,

544
0:39:22,200 --> 0:39:27,560
 meaning that it's going to fail when I log into stuff, and if I look in my SSH folder,

545
0:39:27,560 --> 0:39:32,960
 you see that I have no keys in my folder, that's why I had to do the SSH add before,

546
0:39:32,960 --> 0:39:38,520
 so you would very much expect that if I try to SSH into something, then that will fail,

547
0:39:38,520 --> 0:39:49,100
 I have no keys on disk, so let's try it, and then it asks me for a pin, and now in this

548
0:39:49,100 --> 0:39:57,980
 case SSH is a label in my TPM, and I really hope I can remember the key, and then it worked,

549
0:39:57,980 --> 0:40:04,340
 right, so this is very cool, now it means that if you hack my laptop, there's nothing

550
0:40:04,340 --> 0:40:11,940
 to steal, you can ask my TPM live to sign something, but when I close down the screen

551
0:40:11,940 --> 0:40:19,740
 or put out the battery, then I know that nobody can re-sign stuff on my behalf.

552
0:40:19,740 --> 0:40:28,220
 Yeah, okay, there's a bunch of stuff that doesn't really work, or you get a bunch of error messages

553
0:40:28,220 --> 0:40:35,980
 when you do it, but that's, yeah. All right, so I have a bunch of random configs,

554
0:40:35,980 --> 0:40:41,860
 and I'll go through them very quickly, because I guess you all know them, so ADSs are very

555
0:40:41,860 --> 0:40:53,380
 cool, and let's actually look at my SSH config. So, aliases, I have a bunch of stuff that

556
0:40:53,380 --> 0:40:58,780
 I just don't remember the name of, so you can add these maps to that, and then you can

557
0:40:58,780 --> 0:41:03,660
 also tap completed, and if you have weird options, then you can also add that to your

558
0:41:03,660 --> 0:41:14,100
 config. Then, if you ever do like a SCP and you copy paste a file, but you cannot remember

559
0:41:14,100 --> 0:41:21,100
 what that path is again, then you should for sure look into multiplexing or control master.

560
0:41:21,100 --> 0:41:27,540
 Let's see if we can do a good demo. So, currently it is disabled, so if I go, let's move all

561
0:41:27,900 --> 0:41:46,900
 of this. Let's see. So, what is the, I'm trying to tap complete, oh, it's slow, slow, slow.

562
0:41:47,660 --> 0:41:59,660
 Okay, that's a root, so slow, right? Let's enable the control master, and let's try again.

563
0:42:05,660 --> 0:42:10,220
 What's in root? It takes a long time to generate the first connection, but now I'm connected,

564
0:42:10,220 --> 0:42:15,460
 so I should be able to easily see, be like, oh, there's a bunch of files in temp. I don't

565
0:42:16,020 --> 0:42:21,900
 want to show my files, but I can actually pretty quickly tap complete stuff, and how

566
0:42:21,900 --> 0:42:30,900
 does it work? Whoops. If I go to my SSH folder, I have a folder called control master, and

567
0:42:30,900 --> 0:42:36,620
 in this folder I just have a socket, so whenever I need to create a new connection, it just

568
0:42:36,620 --> 0:42:43,620
 looks in this folder, is there already a socket? You see that the socket is username at domain

569
0:42:43,940 --> 0:42:50,940
 port, and that comes from the config. So, I spent a lot of time debugging, my random

570
0:42:52,620 --> 0:42:57,940
 options didn't work, and in that, in my case, it was because I was adding the option down

571
0:42:57,940 --> 0:43:04,940
 here, but I had a control master already open, so SSH did not know that I changed the options,

572
0:43:04,940 --> 0:43:09,980
 right? So, you see, RP, RHP, whatever, you can add more stuff to that, and it probably

573
0:43:09,980 --> 0:43:16,220
 should be much more like, I would love for this to be like a hash of everything, right?

574
0:43:16,220 --> 0:43:20,500
 Every single option. So, if I went down here and changed one of the options, it would automatically

575
0:43:20,500 --> 0:43:27,500
 know that it has to create a new socket. That doesn't work. You easily get stuck on that.

576
0:43:28,780 --> 0:43:35,540
 And then you see this is to get the TPM working, adding all the ETM stuff. If you use kitty,

577
0:43:35,540 --> 0:43:41,060
 then you probably want to ask, automatically send the environment variables to unbrick

578
0:43:41,060 --> 0:43:47,940
 your terminal, and so on. So, a lot of options, they are very nice, look into it. Jump post,

579
0:43:47,940 --> 0:43:54,940
 also instead of first SSHing into something and then SSHing further along. Alright, hardening.

580
0:43:55,680 --> 0:44:02,680
 If you change all the configs I showed you, ETM, removing old ciphers, deleting old keys

581
0:44:02,680 --> 0:44:06,400
 and so on, you probably will see this in your log. Random people trying to connect

582
0:44:06,400 --> 0:44:11,720
 to a server, to brute force, and then they can't even do a key exchange. I think that's

583
0:44:11,720 --> 0:44:16,760
 pretty cool. I hope some spammers are trying to debug why they also get where they were

584
0:44:16,760 --> 0:44:23,760
 in their int. That would be fun. There's a very nice tool called SSH audit where you

585
0:44:24,040 --> 0:44:29,280
 can test both your server and your client. They write something about there's some ciphers

586
0:44:29,320 --> 0:44:36,320
 made by NIST that I might be backdoored. I think that's a bit bullshit, but what not.

587
0:44:39,280 --> 0:44:46,280
 I tried to get recently this CV found in agent forwarding, and the idea was that if you do

588
0:44:46,560 --> 0:44:53,560
 agent forwarding, then I'm on one server, I go to another server, and I have forwarded

589
0:44:53,600 --> 0:45:00,600
 my agent. I have a socket that you can use to ask my agent to assign something. That's

590
0:45:00,800 --> 0:45:07,800
 bad by itself, but what if I on this attacker system could get my agent to do RCE, if I

591
0:45:09,840 --> 0:45:16,220
 could do a remote code execution on the original system. Then there are some people who found

592
0:45:16,220 --> 0:45:23,220
 out that there's a bug. It's written in C. Surprise, surprise. But I don't know what

593
0:45:23,560 --> 0:45:27,840
 happened. Actually, I couldn't get it to work, which was a bit annoying. But to get

594
0:45:27,840 --> 0:45:33,400
 it to work, you would do the following. First, you would still the socket of whoever you

595
0:45:33,400 --> 0:45:40,400
 are targeting. Then you can use SSH add to ask the agent on the target system to load

596
0:45:41,640 --> 0:45:47,240
 a library, and apparently there's no restrictions on what library can you load. The only restriction

597
0:45:47,240 --> 0:45:54,240
 is it has to be a library already on your system. Then they found out that if you install

598
0:45:56,040 --> 0:46:02,840
 the right amount of packages, at least from some packages, then you can actually get them

599
0:46:02,840 --> 0:46:09,840
 to execute code by just loading and unloading them. That's very amazing. In this case, if

600
0:46:10,840 --> 0:46:17,840
 you load this binary, then your stack will be executable. Of course, there's a buffer

601
0:46:18,320 --> 0:46:25,320
 overflow in some code, so you could store a bunch of stuff on the stack. Then if you

602
0:46:25,400 --> 0:46:30,480
 load this library, there's whatever signal handler that would be registered, but it will

603
0:46:30,480 --> 0:46:35,800
 point to some memory address. Then you unload the library so now it points to nothing. Then

604
0:46:35,800 --> 0:46:42,160
 you load this one, and it has some kind of no deletes thingy, so now this SIG handler

605
0:46:42,160 --> 0:46:46,960
 will point to some random place in this new library. You unload it, but it has no deletes,

606
0:46:46,960 --> 0:46:52,160
 so it's still there. Then if you load this one, it will trigger the signal handler. The

607
0:46:52,160 --> 0:46:57,280
 signal handler will run some random code somewhere, which will end up jumping to your stack, and

608
0:46:57,280 --> 0:47:04,280
 the stack is full of knobs and then some code. This was from a research perspective, super

609
0:47:05,280 --> 0:47:11,040
 amazing. From an SSH perspective, it's not very relevant. If you do agent forwarding

610
0:47:11,040 --> 0:47:18,040
 on a system that is already compromised, you have already lost. Yeah, so very cool. Look

611
0:47:19,440 --> 0:47:26,440
 into it. Final remarks. I was expecting the count to be much higher, but I only lost access

612
0:47:28,260 --> 0:47:33,240
 to my server one time for the last three years, and then I had the broken DNS. But if you

613
0:47:33,240 --> 0:47:37,240
 play around with stuff, make sure you can get access. It's very easy to lock yourself

614
0:47:37,240 --> 0:47:44,240
 out of the system. Then when you go home and generate a bunch of new fancy ED25519 keys,

615
0:47:50,040 --> 0:47:57,040
 then you can use OpenSSH copy ID to just copy all your keys over to servers. This is a very

616
0:47:57,320 --> 0:48:04,320
 nice tool. So you just copy all my keys to a new server, and then you're good. So that's

617
0:48:04,840 --> 0:48:11,840
 actually it. Yeah. Do we have any questions?

618
0:48:27,040 --> 0:48:34,040
 So, you just said we can use SSH copy ID to copy all of our keys to a server. Would it

619
0:48:37,400 --> 0:48:43,800
 make sense to have different SSH keys for different servers, or is that not really that

620
0:48:43,800 --> 0:48:48,280
 important? Yeah, so you've probably corrected a bit.

621
0:48:48,280 --> 0:48:53,360
 So you can copy all your public keys to a server, but of course if you have many public

622
0:48:53,360 --> 0:48:58,280
 keys, you might restrict. If I have one very important server, I probably don't want all

623
0:48:58,280 --> 0:49:05,040
 of my keys there. I don't need the FIDO-protected keys or whatnot. So for sure, if you actually

624
0:49:05,040 --> 0:49:12,040
 do this on a mall, not on just a hobby level, then you should not just randomly copy keys.

625
0:49:15,720 --> 0:49:21,920
 Thanks for that talk. I was wondering, do you know, having looked at the protocol, if

626
0:49:21,920 --> 0:49:28,320
 you don't verify the server's public key, but you're using public key authentication,

627
0:49:28,320 --> 0:49:33,320
 so the server knows your public key, but you don't know it, can somebody actually do a

628
0:49:33,320 --> 0:49:38,040
 man in the middle attack, or could they just give you a fake shell? Like obviously they

629
0:49:38,040 --> 0:49:41,000
 could give you a different server. So you try to log in and the man in the middle just

630
0:49:41,000 --> 0:49:44,840
 gives you a different server completely. You can't authenticate the server. But it seems

631
0:49:44,840 --> 0:49:50,880
 like the encryption could be reliant on your authentication key in some way, and I'm wondering

632
0:49:50,880 --> 0:49:57,520
 if you know if SSH does that. If you're a man in the middle and the user doesn't know

633
0:49:57,520 --> 0:50:00,400
 the server's public key, can you actually man in the middle them when they're using

634
0:50:00,400 --> 0:50:07,400
 public key authentication? You are going to sign the session identifier hash, right? That

635
0:50:10,560 --> 0:50:16,560
 should point uniquely to my current session. So that would be towards the real server or

636
0:50:16,640 --> 0:50:23,640
 towards a completely fake man in the middle server. So if I haven't checked, if I don't

637
0:50:24,400 --> 0:50:31,400
 know the server's public key and I'm connecting to a wrong server, then I'm not sure. I think

638
0:50:37,680 --> 0:50:42,200
 I would have to draw it, but I think, you know, I would be cheated, but you cannot take

639
0:50:42,200 --> 0:50:49,200
 my proof and forward it to the other server. Yes, I agree with that. So the server key

640
0:50:50,280 --> 0:50:57,280
 is in the key exchange phase, which is quite early, way, way before there is any authentication

641
0:50:57,960 --> 0:51:04,960
 of the client going on. And once the client gets an authentication challenge for the public

642
0:51:05,000 --> 0:51:12,000
 key, it will sign it, right? And there's no verification of the server anymore. And then

643
0:51:12,200 --> 0:51:17,200
 it will go to the other server at that stage. Yeah.

644
0:51:17,200 --> 0:51:24,200
 Any more questions? Oh, don't spy on these lads. Let's give Nikolai another round of

645
0:51:24,200 --> 0:51:31,200
 applause for a fantastic talk.